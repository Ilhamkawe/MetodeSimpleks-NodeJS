const assert = require('assert');
const mathjs = require('mathjs');

function mapVector(namedVector) {
  const varNames = Object.keys(namedVector).sort();
  const indicesToNames = {};
  const namesToIndices = {};
  const vectorValues = [];
  varNames.forEach((coefficientName, index) => {
    indicesToNames[`${index}`] = coefficientName;
    namesToIndices[coefficientName] = index;
    vectorValues.push(namedVector[coefficientName]);
  });
  return {
    varNames: varNames,
    indicesToNames: indicesToNames,
    namesToIndices: namesToIndices,
    vectorValues: vectorValues
  };
}

function completeCoefficientVector({
  vector: vector,
  allNames: allNames
}) {
  const nextVector = {};
  allNames.forEach(curName => {
    const vectorValue = vector[curName];
    const curValue = vectorValue || 0;
    nextVector[curName] = curValue;
  });
  return nextVector;
}

function assertCoefficientParallelism({
  objective: objective,
  constraints: constraints
}) {
  const objectiveVector = mapVector(objective).varNames;
  const constraintVectors = constraints.map(constraint => mapVector(constraint.namedVector).varNames);
  constraintVectors.forEach(constraintVector => {
    assert.deepEqual(constraintVector, objectiveVector);
  });
}

function generateTableauRow({
  vectorValues: vectorValues,
  constant = 0,
  rowNo = 0,
  numRows = 1
}) {
  const firstPart = vectorValues;
  const firstZeroes = new Array(rowNo).fill(0);
  const secondZeroes = new Array(numRows - rowNo - 1).fill(0);
  const secondPart = [...firstZeroes, 1, ...secondZeroes];
  return [...firstPart, ...secondPart, constant];
}

function constraintToPreRow({
  namedVector: namedVector,
  constraint: constraint,
  constant = 0
}) {
  const { vectorValues: vectorValues } = mapVector(namedVector);
  if (constraint === '<=') {
    return {
      vectorValues: vectorValues,
      constant: constant
    };
  } else if (constraint === '>=') {
    return {
      vectorValues: mathjs.multiply(vectorValues, -1),
      constant: constant * -1
    };
  }
  throw new Error('Not in standardized form');
}

function getLastRow(tableau) {
  return tableau[tableau.length - 1];
}

function getColumn({
  tableau: tableau,
  columnNo: columnNo
}) {
  return tableau.map(row => row[columnNo]);
}

function getLastColumn(tableau) {
  const columnNo = tableau[0].length - 1;
  return getColumn({
    tableau: tableau,
    columnNo: columnNo
  });
}

function getPivotColumnIndex(tableau) {
  const lastRow = getLastRow(tableau);
  const pivotColumnPair = lastRow.reduce((accMin, curEntry, curIndex) => {
    if (accMin.value <= curEntry) return accMin;
    return { value: curEntry, index: curIndex };
  }, { value: 0, index: -1 });
  return pivotColumnPair.index;
}

function getPivotRowIndex(tableau) {
  const lastColumn = getLastColumn(tableau);
  const lastConstraintColumn = lastColumn.slice(0, lastColumn.length - 1);
  const pivotColumnIndex = getPivotColumnIndex(tableau);
  const pivotColumn = getColumn({
    tableau: tableau,
    columnNo: pivotColumnIndex
  });
  const pivotConstraintColumn = pivotColumn.slice(0, pivotColumn.length - 1);
  const dividedLastColumn = lastConstraintColumn.map((entry, index) => entry / pivotConstraintColumn[index]);
  const pivotRowPair = dividedLastColumn.reduce((accMin, curEntry, curIndex) => {
    // can the acc min be negative?
    if (pivotConstraintColumn[curIndex] < 0) return accMin;
    if (accMin.value <= curEntry) return accMin;
    if (curEntry < 0) return accMin;
    return { value: curEntry, index: curIndex };
  }, { value: Infinity, index: -1 });
  return pivotRowPair.index;
}

function adjustNonPivotRow({
  nonPivotRow: nonPivotRow,
  adjustedPivotRow: adjustedPivotRow,
  pivotCoords: pivotCoords
}) {
  const {
    colNo: colNo
  } = pivotCoords;
  const pivotRowMultiplier = nonPivotRow[colNo] * -1;
  const multipliedPivotRow = mathjs.multiply(adjustedPivotRow, pivotRowMultiplier);
  const adjustedInputRow = mathjs.add(nonPivotRow, multipliedPivotRow);
  adjustedInputRow[colNo] = 0;
  return adjustedInputRow;
}

function adjustPivotRow({
  pivotRow: pivotRow,
  pivotCoords: pivotCoords
}) {
  const {
    colNo: colNo
  } = pivotCoords;
  const pivotEntry = pivotRow[colNo];
  const adjustedPivotRow = pivotRow.map(curEntry => curEntry / pivotEntry);
  adjustedPivotRow[colNo] = 1;
  return adjustedPivotRow;
}

function getPivotCoords(tableau) {
  return {
    rowNo: getPivotRowIndex(tableau),
    colNo: getPivotColumnIndex(tableau)
  };
}

function applyPivoting(tableau) {
  const pivotCoords = getPivotCoords(tableau);
  const {
    rowNo: rowNo
  } = pivotCoords;
  const pivotRow = tableau[rowNo];
  const adjustedPivotRow = adjustPivotRow({
    pivotRow: pivotRow,
    pivotCoords: pivotCoords
  });
  const nextTableau = tableau.map((curRow, curIndex) => {
    if (curIndex === rowNo) return pivotRow;
    return adjustNonPivotRow({
      nonPivotRow: curRow,
      adjustedPivotRow: adjustedPivotRow,
      pivotCoords: pivotCoords
    });
  });
  return nextTableau;
}

function isAllNonNegative(vector) {
  return vector.reduce((acc, curItem) => acc && curItem >= 0, true);
}

function isActive(vector) {
  const numNonZeroes = vector.reduce((acc, curItem) => {
    if (curItem === 0) return acc;
    return acc + 1;
  });
  return numNonZeroes === 1;
}

function getActiveVarCoefficient(column) {
  return column.reduce((acc, curEntry) => {
    if (curEntry === 0) return acc;
    return curEntry;
  }, 0);
}

function extractNamedSolution({
  tableau: tableau,
  indicesToNames: indicesToNames,
  allNames: allNames
}) {
  const lastColumn = getLastColumn(tableau);
  const allColumns = mathjs.transpose(tableau);
  const activeColumnIndices = allColumns.map((curColumn, curIndex) => ({
    isActiveColumn: isActive(curColumn),
    index: curIndex
  })).filter(({ isActiveColumn: isActiveColumn }) => isActiveColumn).map(({ index: index }) => index);
  const activeVarCoefficients = activeColumnIndices.map(curActiveIndex => getActiveVarCoefficient(allColumns[curActiveIndex]));
  const activeVarIndicesAndValues = activeVarCoefficients.map((curCoefficient, curIndex) => {
    const curActiveIndex = activeColumnIndices[curIndex];
    const curActiveValue = lastColumn[curIndex] / curCoefficient;
    return {
      index: curActiveIndex,
      value: curActiveValue
    };
  });
  const vector = {};
  activeVarIndicesAndValues.forEach(({ index: index, value: value }) => {
    const indexString = `${index}`;
    if (!indicesToNames[indexString]) return;
    const coefficientName = indicesToNames[indexString];
    vector[coefficientName] = value;
  });
  const optimum = activeVarIndicesAndValues[activeVarIndicesAndValues.length - 1].value;
  const coefficients = completeCoefficientVector({
    vector: vector,
    allNames: allNames
  });
  return {
    coefficients: coefficients,
    optimum: optimum
  };
}

module.exports = {
  mapVector: mapVector,
  assertCoefficientParallelism: assertCoefficientParallelism,
  generateTableauRow: generateTableauRow,
  constraintToPreRow: constraintToPreRow,
  getPivotColumnIndex: getPivotColumnIndex,
  getPivotRowIndex: getPivotRowIndex,
  getPivotCoords: getPivotCoords,
  getLastRow: getLastRow,
  applyPivoting: applyPivoting,
  adjustPivotRow: adjustPivotRow,
  adjustNonPivotRow: adjustNonPivotRow,
  isAllNonNegative: isAllNonNegative,
  isActive: isActive,
  extractNamedSolution: extractNamedSolution,
  completeCoefficientVector: completeCoefficientVector
};
